const functions = require("firebase-functions");
const { TextToSpeechClient } = require("@google-cloud/text-to-speech");
const admin = require("firebase-admin");
const axios = require("axios");
const jwt = require("jsonwebtoken");

// Firebase Admin Ï¥àÍ∏∞Ìôî
if (!admin.apps.length) {
  admin.initializeApp();
}

const client = new TextToSpeechClient();

exports.synthesizeSpeech = functions.https.onCall(async (data, context) => {
  const text = data.text;
  if (!text) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "The function must be called with one argument 'text'."
    );
  }

  let ssmlText = '';
  const words = text.split(' ');
  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    ssmlText += `${word}<mark name="${i}"/> `;
  }
  const ssml = `<speak>${ssmlText.trim()}</speak>`;

  const request = {
    input: { ssml },
    // Î™©ÏÜåÎ¶¨Î•º WaveNet Í∏∞Î∞òÏùò Ïó¨ÏÑ± ÏùåÏÑ±ÏúºÎ°ú Î≥ÄÍ≤Ω
    voice: { languageCode: "en-US", name: "en-US-Wavenet-F" },
    audioConfig: { audioEncoding: "MP3" },
    enableTimePointing: ["SSML_MARK"],
  };

  try {
    const [response] = await client.synthesizeSpeech(request);

    const timepoints = response.timepoints
      .map(point => ({
        markName: parseInt(point.markName, 10),
        timeSeconds: point.timeSeconds,
      }))
      .sort((a, b) => a.markName - b.markName);

    const result = {
      audioContent: response.audioContent.toString("base64"),
      timepoints: timepoints,
    };

    return result;

  } catch (error) {
    console.error("ERROR:", error);
    throw new functions.https.HttpsError(
      "internal",
      "Failed to synthesize speech.",
      error
    );
  }
});

// ÎÑ§Ïù¥Î≤Ñ ÏÜåÏÖú Î°úÍ∑∏Ïù∏ Ïù∏Ï¶ù Ìï®Ïàò (ÏóÖÎç∞Ïù¥Ìä∏Îê®)
exports.naverAuth = functions.https.onRequest(async (req, res) => {
  // CORS Ìó§Îçî ÏÑ§Ï†ï
  res.set('Access-Control-Allow-Origin', 'https://marlang-app.web.app');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  res.set('Access-Control-Allow-Credentials', 'true');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    const { code, state } = req.body;
    
    if (!code || !state) {
      res.status(400).json({ error: 'Missing code or state parameter' });
      return;
    }

    // ÎÑ§Ïù¥Î≤Ñ ÌôòÍ≤Ω Î≥ÄÏàò (process.envÏóêÏÑú Í∞ÄÏ†∏Ïò¥)
    const naverClientId = process.env.NAVER_CLIENT_ID;
    const naverClientSecret = process.env.NAVER_CLIENT_SECRET;
    
    if (!naverClientId || !naverClientSecret) {
      console.error('üö® Missing Naver OAuth credentials');
      res.status(500).json({ 
        error: 'Server configuration error',
        message: 'OAuth credentials not configured' 
      });
      return;
    }
    
    // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏ (Ïã§Ï†ú Í∞íÏùÄ Î°úÍ∑∏Ïóê ÎÇ®Í∏∞ÏßÄ ÏïäÏùå)
    console.log('ÌôòÍ≤ΩÎ≥ÄÏàò ÌôïÏù∏:', {
      hasClientId: !!naverClientId,
      hasClientSecret: !!naverClientSecret,
      envKeys: Object.keys(process.env).filter(key => key.includes('NAVER') || key.includes('JWT'))
    });
    const redirectUri = 'https://marlang-app.web.app/auth/naver/callback';

    // 1. ÎÑ§Ïù¥Î≤Ñ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ ÏöîÏ≤≠
    console.log('ÌÜ†ÌÅ∞ ÏöîÏ≤≠ ÌååÎùºÎØ∏ÌÑ∞:', {
      grant_type: 'authorization_code',
      client_id: naverClientId,
      client_secret: naverClientSecret.substring(0, 3) + '***',
      code: code.substring(0, 10) + '***',
      state: state,
      redirect_uri: redirectUri
    });

    const tokenResponse = await axios.post('https://nid.naver.com/oauth2.0/token', null, {
      params: {
        grant_type: 'authorization_code',
        client_id: naverClientId,
        client_secret: naverClientSecret,
        code: code,
        state: state,
        redirect_uri: redirectUri
      }
    });

    console.log('ÎÑ§Ïù¥Î≤Ñ ÌÜ†ÌÅ∞ ÏùëÎãµ:', tokenResponse.data);
    const { access_token } = tokenResponse.data;

    if (!access_token) {
      console.error('ÎÑ§Ïù¥Î≤Ñ ÌÜ†ÌÅ∞ ÏùëÎãµ Ï†ÑÏ≤¥:', tokenResponse.data);
      throw new Error(`Failed to get access token from Naver: ${JSON.stringify(tokenResponse.data)}`);
    }

    // 2. ÎÑ§Ïù¥Î≤Ñ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠
    const userResponse = await axios.get('https://openapi.naver.com/v1/nid/me', {
      headers: {
        'Authorization': `Bearer ${access_token}`
      }
    });

    console.log('ÎÑ§Ïù¥Î≤Ñ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏùëÎãµ:', userResponse.data);
    const naverUser = userResponse.data.response;
    
    if (!naverUser) {
      console.error('ÎÑ§Ïù¥Î≤Ñ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏùëÎãµ Ï†ÑÏ≤¥:', userResponse.data);
      throw new Error(`Failed to get user info from Naver: ${JSON.stringify(userResponse.data)}`);
    }

    // 3. Firebase AuthÏóê ÎÑ§Ïù¥Î≤Ñ ÏÇ¨Ïö©Ïûê Îì±Î°ù/ÏóÖÎç∞Ïù¥Ìä∏
    const uid = `naver_${naverUser.id}`;
    
    try {
      // Í∏∞Ï°¥ ÏÇ¨Ïö©Ïûê ÌôïÏù∏
      await admin.auth().getUser(uid);
      console.log('Í∏∞Ï°¥ Firebase ÏÇ¨Ïö©Ïûê Î∞úÍ≤¨:', uid);
    } catch (error) {
      if (error.code === 'auth/user-not-found') {
        // ÏÉà ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±
        console.log('ÏÉà Firebase ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±:', uid);
        await admin.auth().createUser({
          uid: uid,
          email: naverUser.email || `${uid}@naver.temp`,
          displayName: naverUser.name || naverUser.nickname || 'Unknown',
          photoURL: naverUser.profile_image || null
        });
      } else {
        throw error;
      }
    }

    // 4. Ïª§Ïä§ÌÖÄ ÌÜ†ÌÅ∞ ÏÉùÏÑ±
    let customToken = null;
    let tokenType = 'server_auth'; // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏÑúÎ≤Ñ Ïù∏Ï¶ù Î™®Îìú
    
    try {
      // Ïª§Ïä§ÌÖÄ ÌÜ†ÌÅ∞ ÏÉùÏÑ± ÏãúÎèÑ
      customToken = await admin.auth().createCustomToken(uid, {
        provider: 'naver',
        naverUserId: naverUser.id
      });
      tokenType = 'custom';
      console.log('‚úÖ Ïª§Ïä§ÌÖÄ ÌÜ†ÌÅ∞ ÏÉùÏÑ± ÏÑ±Í≥µ');
    } catch (tokenError) {
      console.log('‚ö†Ô∏è Ïª§Ïä§ÌÖÄ ÌÜ†ÌÅ∞ ÏÉùÏÑ± Ïã§Ìå®, ÏÑúÎ≤Ñ Ïù∏Ï¶ù Î™®Îìú ÏÇ¨Ïö©:', tokenError.message);
      // IAM Í∂åÌïú Î¨∏Ï†úÍ∞Ä ÏûàÏñ¥ÎèÑ ÏÑúÎ≤Ñ Ïù∏Ï¶ù Î™®ÎìúÎ°ú Í≥ÑÏÜç ÏßÑÌñâ
      customToken = null;
      tokenType = 'server_auth';
    }

    // 5. FirestoreÏóê ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï†ÄÏû•/ÏóÖÎç∞Ïù¥Ìä∏
    console.log('ÎÑ§Ïù¥Î≤Ñ ÏÇ¨Ïö©Ïûê ÏÉÅÏÑ∏ Ï†ïÎ≥¥:', {
      id: naverUser.id,
      email: naverUser.email,
      name: naverUser.name,
      nickname: naverUser.nickname,
      profile_image: naverUser.profile_image
    });

    const userDoc = {
      uid: uid,
      email: naverUser.email || null,
      name: naverUser.name || naverUser.nickname || 'Unknown',
      picture: naverUser.profile_image || null,
      provider: 'naver',
      role: 'user',
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    // Í∏∞Ï°¥ ÏÇ¨Ïö©ÏûêÏù∏ÏßÄ ÌôïÏù∏
    const userRef = admin.firestore().collection('users').doc(uid);
    const existingUser = await userRef.get();
    
    if (!existingUser.exists) {
      userDoc.createdAt = admin.firestore.FieldValue.serverTimestamp();
    }
    
    await userRef.set(userDoc, { merge: true });

    // 6. Í∏∞Ï°¥ localStorage Î∞©Ïãù ÏùëÎãµ
    const responseData = { 
      success: true,
      tokenType: 'server_auth',
      user: {
        uid: uid,
        email: naverUser.email || null,
        name: naverUser.name || naverUser.nickname || 'Unknown',
        picture: naverUser.profile_image || null,
        provider: 'naver',
        isServerAuth: true
      }
    };

    console.log('üì§ ÏÑúÎ≤Ñ Ïù∏Ï¶ù ÏùëÎãµ:', {
      success: responseData.success,
      tokenType: responseData.tokenType,
      userEmail: responseData.user.email
    });

    res.json(responseData);

  } catch (error) {
    console.error('Naver auth error:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});

// ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ìï®Ïàò
exports.saveUserData = functions.https.onRequest(async (req, res) => {
  // CORS Ìó§Îçî ÏÑ§Ï†ï
  res.set('Access-Control-Allow-Origin', 'https://marlang-app.web.app');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    const { userId, dataType, data, userInfo } = req.body;
    
    if (!userId || !dataType || !data) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    // FirestoreÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    const userDataRef = admin.firestore().collection('users').doc(userId).collection('data').doc(dataType);
    
    const payload = {
      [dataType === 'savedWords' ? 'words' : 
        dataType === 'likedArticles' ? 'articles' :
        dataType === 'settings' ? 'settings' : 'records']: data,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    await userDataRef.set(payload, { merge: true });

    // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
    if (userInfo) {
      const userRef = admin.firestore().collection('users').doc(userId);
      await userRef.set({
        ...userInfo,
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    }

    console.log(`‚úÖ ÏÇ¨Ïö©Ïûê ${userId}Ïùò ${dataType} Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å`);

    res.json({ 
      success: true,
      message: `${dataType} data saved successfully`
    });

  } catch (error) {
    console.error('Save user data error:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});

// ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ìï®Ïàò
exports.getUserData = functions.https.onRequest(async (req, res) => {
  // CORS Ìó§Îçî ÏÑ§Ï†ï
  res.set('Access-Control-Allow-Origin', 'https://marlang-app.web.app');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'GET') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    const userId = req.query.userId;
    
    if (!userId) {
      res.status(400).json({ error: 'Missing userId parameter' });
      return;
    }

    // FirestoreÏóêÏÑú Î™®Îì† ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    const userDataCollection = admin.firestore().collection('users').doc(userId).collection('data');
    const snapshot = await userDataCollection.get();

    const userData = {
      savedWords: [],
      likedArticles: [],
      settings: {},
      viewRecords: []
    };

    snapshot.forEach(doc => {
      const docId = doc.id;
      const docData = doc.data();
      
      if (docId === 'savedWords' && docData.words) {
        userData.savedWords = docData.words;
      } else if (docId === 'likedArticles' && docData.articles) {
        userData.likedArticles = docData.articles;
      } else if (docId === 'settings' && docData.settings) {
        userData.settings = docData.settings;
      } else if (docId === 'viewRecords' && docData.records) {
        userData.viewRecords = docData.records;
      }
    });

    console.log(`‚úÖ ÏÇ¨Ïö©Ïûê ${userId}Ïùò Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å`);

    res.json(userData);

  } catch (error) {
    console.error('Get user data error:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});

// JWT ÌÜ†ÌÅ∞ ÏÉùÏÑ± Ìï®Ïàò
exports.createJWTToken = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', 'https://marlang-app.web.app');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  res.set('Access-Control-Allow-Credentials', 'true');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    const { userId, userInfo } = req.body;
    
    if (!userId || !userInfo) {
      res.status(400).json({ error: 'Missing userId or userInfo' });
      return;
    }

    const jwtSecret = process.env.JWT_SECRET || (() => {
      console.warn('‚ö†Ô∏è Using default JWT secret - set JWT_SECRET environment variable');
      return 'haru-default-jwt-secret-2025';
    })();
    const accessTokenExpiry = '15m'; // 15Î∂Ñ
    const refreshTokenExpiry = '7d'; // 7Ïùº

    // Access Token ÏÉùÏÑ±
    const accessToken = jwt.sign(
      { 
        userId: userId,
        email: userInfo.email,
        provider: userInfo.provider,
        type: 'access'
      },
      jwtSecret,
      { expiresIn: accessTokenExpiry }
    );

    // Refresh Token ÏÉùÏÑ±
    const refreshToken = jwt.sign(
      { 
        userId: userId,
        type: 'refresh'
      },
      jwtSecret,
      { expiresIn: refreshTokenExpiry }
    );

    // HttpOnly Ïø†ÌÇ§ ÏÑ§Ï†ï
    const isProduction = req.get('host')?.includes('cloudfunctions.net');
    const cookieOptions = {
      httpOnly: true,
      secure: true,
      sameSite: 'none',
      maxAge: 15 * 60 * 1000, // 15Î∂Ñ
      path: '/'
    };

    res.cookie('accessToken', accessToken, cookieOptions);

    res.cookie('refreshToken', refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7Ïùº
    });

    res.json({ 
      success: true,
      message: 'JWT tokens created successfully',
      user: {
        uid: userId,
        email: userInfo.email,
        name: userInfo.name,
        provider: userInfo.provider
      }
    });

  } catch (error) {
    console.error('Create JWT token error:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});

// JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ìï®Ïàò
exports.verifyJWTToken = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', 'https://marlang-app.web.app');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  res.set('Access-Control-Allow-Credentials', 'true');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'GET') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    console.log('üîç Ïø†ÌÇ§ ÌôïÏù∏:', req.cookies);
    const accessToken = req.cookies?.accessToken;
    
    if (!accessToken) {
      console.log('‚ùå Access tokenÏù¥ Ïø†ÌÇ§Ïóê ÏóÜÏùå');
      res.status(401).json({ error: 'No access token found' });
      return;
    }

    const jwtSecret = process.env.JWT_SECRET || (() => {
      console.warn('‚ö†Ô∏è Using default JWT secret - set JWT_SECRET environment variable');
      return 'haru-default-jwt-secret-2025';
    })();
    
    try {
      const decoded = jwt.verify(accessToken, jwtSecret);
      console.log('‚úÖ JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÏÑ±Í≥µ:', decoded.userId);
      
      if (decoded.type !== 'access') {
        res.status(401).json({ error: 'Invalid token type' });
        return;
      }

      // FirestoreÏóêÏÑú ÏµúÏã† ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
      const userRef = admin.firestore().collection('users').doc(decoded.userId);
      const userDoc = await userRef.get();
      
      if (!userDoc.exists) {
        res.status(401).json({ error: 'User not found' });
        return;
      }

      const userInfo = userDoc.data();

      res.json({
        success: true,
        user: {
          uid: decoded.userId,
          email: userInfo.email,
          name: userInfo.name,
          picture: userInfo.picture,
          provider: userInfo.provider
        }
      });

    } catch (jwtError) {
      console.error('JWT Í≤ÄÏ¶ù Ïò§Î•ò:', jwtError);
      if (jwtError.name === 'TokenExpiredError') {
        res.status(401).json({ error: 'Token expired' });
      } else {
        res.status(401).json({ error: 'Invalid token' });
      }
    }

  } catch (error) {
    console.error('Verify JWT token error:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});

// JWT ÌÜ†ÌÅ∞ Í∞±Ïã† Ìï®Ïàò
exports.refreshJWTToken = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', 'https://marlang-app.web.app');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  res.set('Access-Control-Allow-Credentials', 'true');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    const refreshToken = req.cookies.refreshToken;
    
    if (!refreshToken) {
      res.status(401).json({ error: 'No refresh token found' });
      return;
    }

    const jwtSecret = process.env.JWT_SECRET || (() => {
      console.warn('‚ö†Ô∏è Using default JWT secret - set JWT_SECRET environment variable');
      return 'haru-default-jwt-secret-2025';
    })();
    
    try {
      const decoded = jwt.verify(refreshToken, jwtSecret);
      
      if (decoded.type !== 'refresh') {
        res.status(401).json({ error: 'Invalid token type' });
        return;
      }

      // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Îã§Ïãú Í∞ÄÏ†∏Ïò§Í∏∞
      const userRef = admin.firestore().collection('users').doc(decoded.userId);
      const userDoc = await userRef.get();
      
      if (!userDoc.exists) {
        res.status(401).json({ error: 'User not found' });
        return;
      }

      const userInfo = userDoc.data();

      // ÏÉà Access Token ÏÉùÏÑ±
      const newAccessToken = jwt.sign(
        { 
          userId: decoded.userId,
          email: userInfo.email,
          provider: userInfo.provider,
          type: 'access'
        },
        jwtSecret,
        { expiresIn: '15m' }
      );

      // ÏÉà Access Token Ïø†ÌÇ§ ÏÑ§Ï†ï
      const isProduction = req.get('host')?.includes('cloudfunctions.net');
      res.cookie('accessToken', newAccessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'none',
        maxAge: 15 * 60 * 1000, // 15Î∂Ñ
        path: '/'
      });

      res.json({ 
        success: true,
        message: 'Token refreshed successfully',
        user: {
          uid: decoded.userId,
          email: userInfo.email,
          name: userInfo.name,
          provider: userInfo.provider
        }
      });

    } catch (jwtError) {
      if (jwtError.name === 'TokenExpiredError') {
        res.status(401).json({ error: 'Refresh token expired' });
      } else {
        res.status(401).json({ error: 'Invalid refresh token' });
      }
    }

  } catch (error) {
    console.error('Refresh JWT token error:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});

// ÏÇ¨Ïö©Ïûê Î°úÍ∑∏ÏïÑÏõÉ Ìï®Ïàò
exports.logoutUser = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', 'https://marlang-app.web.app');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  res.set('Access-Control-Allow-Credentials', 'true');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    // Ïø†ÌÇ§ ÏÇ≠Ï†ú
    const isProduction = req.get('host')?.includes('cloudfunctions.net');
    const clearOptions = {
      httpOnly: true,
      secure: true,
      sameSite: 'none',
      path: '/'
    };

    res.clearCookie('accessToken', clearOptions);
    res.clearCookie('refreshToken', clearOptions);

    res.json({ 
      success: true,
      message: 'Logged out successfully'
    });

  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});
